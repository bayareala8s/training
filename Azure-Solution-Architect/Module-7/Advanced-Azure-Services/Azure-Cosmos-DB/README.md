Azure Cosmos DB is a globally distributed, multi-model database service designed for highly responsive, scalable applications. It offers turnkey global distribution across multiple Azure regions by scaling and replicating your data wherever your users are, and provides comprehensive SLAs for throughput, latency, availability, and consistency.

Here’s a detailed overview of Azure Cosmos DB:

### Key Features:

1. **Global Distribution**:
   - **Multi-Region Replication**: Automatically replicate your data across any number of Azure regions with a single button click.
   - **Low Latency**: Ensures low-latency access to data for users across the globe.
   - **High Availability**: Provides a 99.999% availability SLA for both reads and writes.

2. **Elastic Scalability**:
   - **Automatic Scaling**: Automatically scales storage and throughput as needed.
   - **Provisioned Throughput**: Allows you to specify the throughput (in terms of request units per second) you need for your application.
   - **Serverless**: Offers a consumption-based model where you only pay for the RUs consumed by your database operations.

3. **Multiple Data Models**:
   - Supports document, key-value, graph, and column-family data models, allowing you to work with the best model for your application.
   - Compatible APIs: SQL API, MongoDB API, Cassandra API, Gremlin API, and Table API.

4. **Guaranteed Speed and Performance**:
   - Offers single-digit millisecond response times for both reads and writes.
   - Provides comprehensive SLAs covering latency, throughput, consistency, and high availability.

5. **Consistency Levels**:
   - **Strong**: Guarantees linearizability.
   - **Bounded Staleness**: Guarantees a lag bounded by time or versions.
   - **Session**: Guarantees consistency within a session.
   - **Consistent Prefix**: Guarantees that reads never see out-of-order writes.
   - **Eventual**: Guarantees that all replicas will eventually converge.

6. **Security**:
   - Data encryption at rest and in transit.
   - Integration with Azure Active Directory (AAD) for enhanced security.

### Use Cases:

1. **IoT and Telemetry**: Handling massive amounts of data generated by IoT devices with real-time processing and analytics.
2. **Retail and E-Commerce**: Managing product catalogs, inventory, user profiles, and session data across multiple regions.
3. **Gaming**: Storing player data, leaderboards, and session states with real-time access.
4. **Web and Mobile Applications**: Providing responsive user experiences by storing and retrieving user data, preferences, and session states with low latency.

### Architecture and Components:

1. **Database Account**: The highest level of a Cosmos DB account which provides a unique namespace for your databases.
2. **Databases**: Contain one or more collections or containers.
3. **Containers (or Collections)**: The scalable entities that contain your items (or documents). Containers are automatically partitioned based on your configuration.
4. **Items (or Documents)**: The actual records stored in the containers, which can be JSON documents, key-value pairs, or other data models.

### Integration and Ecosystem:

- **Azure Functions**: Serverless compute can trigger operations based on changes in Cosmos DB.
- **Azure Synapse Analytics**: Integrate for real-time analytics on operational data.
- **Azure Data Factory**: For data movement and transformation.
- **Azure Kubernetes Service (AKS)**: Easily integrate with AKS for deploying scalable applications.

### Pricing:

Azure Cosmos DB pricing is based on:
- **Provisioned Throughput**: Measured in Request Units per second (RUs/s).
- **Storage**: Based on the amount of data stored in GBs.
- **Data Transfer**: Charges for data egress out of Azure regions.

### Best Practices:

1. **Partitioning**: Choose a good partition key to ensure even distribution of data and efficient queries.
2. **Indexing**: Customize indexing policies to optimize performance and reduce costs.
3. **Consistency**: Choose the appropriate consistency level for your application needs to balance between performance and consistency.
4. **Monitoring**: Use Azure Monitor and Azure Cosmos DB diagnostics to monitor the health and performance of your database.

### Getting Started:

1. **Create an Azure Cosmos DB Account**:
   - Navigate to the Azure portal and create a new Cosmos DB account.
   - Choose the appropriate API for your data model.

2. **Create a Database and Container**:
   - Define throughput (RUs) and partition key.
   - Create collections and define indexing policies.

3. **Develop Your Application**:
   - Use SDKs for .NET, Java, Python, Node.js, and other languages to integrate Cosmos DB into your application.
   - Leverage the Azure Cosmos DB emulator for local development and testing.

By understanding these aspects of Azure Cosmos DB, you can effectively design, deploy, and manage globally distributed applications with scalable and performant database capabilities.


Sure, here are some real-world examples illustrating how Azure Cosmos DB is used across different industries:

### 1. Retail and E-Commerce

#### Case Study: Walmart
**Scenario**: Walmart needed to enhance its global inventory and order management system to provide real-time data access and improve customer experience.

**Solution**:
- **Global Distribution**: Walmart used Azure Cosmos DB to replicate data across multiple regions, ensuring that inventory and order data are accessible globally with low latency.
- **Scalability**: The system automatically scaled to handle peak shopping times, such as Black Friday, ensuring that the database could handle the increased load without performance degradation.
- **Multi-Model Support**: By leveraging the document model, Walmart stored complex data structures representing products, inventory levels, and customer orders.

**Benefits**:
- Reduced latency for global users.
- Improved reliability and availability during peak times.
- Enhanced customer experience with real-time data access.

### 2. Gaming

#### Case Study: Microsoft Xbox
**Scenario**: Microsoft needed a solution to manage player data, game state, and leaderboards for millions of Xbox gamers worldwide.

**Solution**:
- **Low Latency**: Azure Cosmos DB provided millisecond read and write latencies, essential for real-time game state updates and leaderboard tracking.
- **Elastic Scalability**: The database scaled to handle the varying load, especially during game launches or updates.
- **Consistency Models**: Different consistency levels were used to balance performance and data accuracy, depending on the specific game requirements.

**Benefits**:
- Seamless player experience with real-time updates.
- Robust data management for millions of users.
- Flexibility in choosing consistency models for different use cases.

### 3. IoT and Telemetry

#### Case Study: Toyota
**Scenario**: Toyota needed to collect, store, and analyze telemetry data from its connected vehicles to provide real-time insights and predictive maintenance.

**Solution**:
- **Time-Series Data**: Toyota used Azure Cosmos DB to store time-series data generated by vehicle sensors, which was crucial for monitoring and diagnostics.
- **Real-Time Processing**: Integrated with Azure Stream Analytics and Azure Functions, Toyota processed incoming data in real-time, triggering alerts and actions based on predefined rules.
- **Global Reach**: Data was replicated across regions to ensure availability and reliability, even in cases of regional failures.

**Benefits**:
- Enhanced vehicle maintenance with real-time insights.
- Improved safety and reliability through proactive monitoring.
- Scalable and resilient data infrastructure.

### 4. Financial Services

#### Case Study: HSBC
**Scenario**: HSBC needed a reliable and scalable database solution to manage transaction data and customer profiles across its global operations.

**Solution**:
- **High Availability**: Azure Cosmos DB ensured 99.999% availability, critical for financial transactions and customer data management.
- **Security**: With built-in encryption and integration with Azure Active Directory, HSBC ensured the security and compliance of its data.
- **Multi-Model Capabilities**: Different data models (document, key-value) were used to manage various types of data, including customer profiles, transaction logs, and audit trails.

**Benefits**:
- Reliable and secure transaction management.
- Improved data compliance and security.
- Flexible data modeling for diverse data types.

### 5. Healthcare

#### Case Study: Philips Healthcare
**Scenario**: Philips needed to manage and analyze patient data from various healthcare devices and applications to improve patient care and outcomes.

**Solution**:
- **Data Integration**: Azure Cosmos DB integrated data from multiple sources, providing a unified view of patient records and health data.
- **Real-Time Analytics**: Leveraging Azure Synapse Analytics, Philips performed real-time analysis on the data stored in Cosmos DB to derive actionable insights.
- **Compliance and Security**: Ensured compliance with healthcare regulations like HIPAA by using Azure’s robust security features.

**Benefits**:
- Enhanced patient care through real-time data access and analysis.
- Unified and integrated patient records.
- Secure and compliant data management.

### Implementation Steps:

#### Step 1: Data Modeling
- Identify the data models (document, key-value, graph, etc.) that fit your application needs.
- Design your data schema and partitioning strategy to ensure optimal performance and scalability.

#### Step 2: Setting Up Azure Cosmos DB
- Create an Azure Cosmos DB account via the Azure portal.
- Configure the database, containers, and partition keys.
- Set the desired throughput (RUs) based on expected load.

#### Step 3: Integrating with Applications
- Use the appropriate SDKs (e.g., .NET, Java, Python, Node.js) to connect your application to Azure Cosmos DB.
- Implement data access patterns (CRUD operations) tailored to your application logic.
- Leverage features like stored procedures, triggers, and user-defined functions to enhance functionality.

#### Step 4: Monitoring and Optimization
- Use Azure Monitor and Cosmos DB metrics to monitor performance and identify bottlenecks.
- Optimize indexing policies and query performance based on usage patterns.
- Adjust throughput settings and partitioning strategies as needed to handle changing load.

By adopting these strategies and leveraging Azure Cosmos DB's capabilities, organizations across various industries can build highly responsive, scalable, and globally distributed applications that meet their specific business requirements.


Here are some example Terraform scripts to set up an Azure Cosmos DB instance. These scripts will create an Azure Cosmos DB account, a database, and a container. 

### Prerequisites:
1. Ensure you have the Azure CLI installed and authenticated.
2. Ensure you have Terraform installed.

### Step 1: Define the Provider

Create a file named `provider.tf` and add the following code to configure the Azure provider.

```hcl
# provider.tf
provider "azurerm" {
  features {}
}
```

### Step 2: Create a Resource Group

Create a file named `resource_group.tf` and add the following code to define the Azure Resource Group.

```hcl
# resource_group.tf
resource "azurerm_resource_group" "rg" {
  name     = "myResourceGroup"
  location = "East US"
}
```

### Step 3: Create the Cosmos DB Account

Create a file named `cosmosdb_account.tf` and add the following code to set up the Cosmos DB account.

```hcl
# cosmosdb_account.tf
resource "azurerm_cosmosdb_account" "cosmosdb" {
  name                = "mycosmosdbaccount"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  offer_type          = "Standard"
  kind                = "GlobalDocumentDB"

  consistency_policy {
    consistency_level       = "Session"
    max_interval_in_seconds = 5
    max_staleness_prefix    = 100
  }

  geo_location {
    location          = azurerm_resource_group.rg.location
    failover_priority = 0
  }
}
```

### Step 4: Create a Cosmos DB Database

Create a file named `cosmosdb_database.tf` and add the following code to define the database.

```hcl
# cosmosdb_database.tf
resource "azurerm_cosmosdb_sql_database" "database" {
  name                = "mycosmosdatabase"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
}
```

### Step 5: Create a Cosmos DB Container

Create a file named `cosmosdb_container.tf` and add the following code to set up the container.

```hcl
# cosmosdb_container.tf
resource "azurerm_cosmosdb_sql_container" "container" {
  name                = "mycosmoscontainer"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
  database_name       = azurerm_cosmosdb_sql_database.database.name
  partition_key_path  = "/myPartitionKey"
  throughput          = 400

  indexing_policy {
    indexing_mode = "consistent"
    included_path {
      path = "/*"
    }
    excluded_path {
      path = "/\"_etag\"/?"
    }
  }
}
```

### Step 6: Initialize and Apply the Configuration

1. Initialize the Terraform configuration:
   ```sh
   terraform init
   ```

2. Apply the configuration:
   ```sh
   terraform apply
   ```

You will be prompted to confirm the execution of the script. Type `yes` to proceed. Terraform will create the specified resources in Azure.

### Summary

These Terraform scripts will:
1. Configure the Azure provider.
2. Create an Azure Resource Group.
3. Set up an Azure Cosmos DB account.
4. Create a Cosmos DB SQL database.
5. Define a Cosmos DB container within the database.

By using these scripts, you can automate the creation and configuration of Azure Cosmos DB resources, ensuring a repeatable and consistent setup. If you have any specific configurations or additional requirements, you can further customize these scripts as needed.


Sure! Here are Terraform scripts for each of the real-world examples:

### 1. Walmart: Retail and E-Commerce

#### Step 1: Define the Provider and Resource Group

```hcl
# provider.tf
provider "azurerm" {
  features {}
}

# resource_group.tf
resource "azurerm_resource_group" "rg" {
  name     = "walmartResourceGroup"
  location = "East US"
}
```

#### Step 2: Create the Cosmos DB Account

```hcl
# cosmosdb_account.tf
resource "azurerm_cosmosdb_account" "cosmosdb" {
  name                = "walmartcosmosdb"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  offer_type          = "Standard"
  kind                = "GlobalDocumentDB"

  consistency_policy {
    consistency_level       = "Strong"
    max_interval_in_seconds = 5
    max_staleness_prefix    = 100
  }

  geo_location {
    location          = "East US"
    failover_priority = 0
  }

  geo_location {
    location          = "West US"
    failover_priority = 1
  }
}
```

#### Step 3: Create the Database and Container

```hcl
# cosmosdb_database.tf
resource "azurerm_cosmosdb_sql_database" "database" {
  name                = "walmartdb"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
}

# cosmosdb_container.tf
resource "azurerm_cosmosdb_sql_container" "container" {
  name                = "inventoryContainer"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
  database_name       = azurerm_cosmosdb_sql_database.database.name
  partition_key_path  = "/productId"
  throughput          = 1000

  indexing_policy {
    indexing_mode = "consistent"
    included_path {
      path = "/*"
    }
    excluded_path {
      path = "/\"_etag\"/?"
    }
  }
}
```

### 2. Microsoft Xbox: Gaming

#### Step 1: Define the Provider and Resource Group

```hcl
# provider.tf
provider "azurerm" {
  features {}
}

# resource_group.tf
resource "azurerm_resource_group" "rg" {
  name     = "xboxResourceGroup"
  location = "West US"
}
```

#### Step 2: Create the Cosmos DB Account

```hcl
# cosmosdb_account.tf
resource "azurerm_cosmosdb_account" "cosmosdb" {
  name                = "xboxcosmosdb"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  offer_type          = "Standard"
  kind                = "GlobalDocumentDB"

  consistency_policy {
    consistency_level       = "Session"
    max_interval_in_seconds = 5
    max_staleness_prefix    = 100
  }

  geo_location {
    location          = "West US"
    failover_priority = 0
  }

  geo_location {
    location          = "East US"
    failover_priority = 1
  }
}
```

#### Step 3: Create the Database and Container

```hcl
# cosmosdb_database.tf
resource "azurerm_cosmosdb_sql_database" "database" {
  name                = "xboxdb"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
}

# cosmosdb_container.tf
resource "azurerm_cosmosdb_sql_container" "container" {
  name                = "playerDataContainer"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
  database_name       = azurerm_cosmosdb_sql_database.database.name
  partition_key_path  = "/playerId"
  throughput          = 2000

  indexing_policy {
    indexing_mode = "consistent"
    included_path {
      path = "/*"
    }
    excluded_path {
      path = "/\"_etag\"/?"
    }
  }
}
```

### 3. Toyota: IoT and Telemetry

#### Step 1: Define the Provider and Resource Group

```hcl
# provider.tf
provider "azurerm" {
  features {}
}

# resource_group.tf
resource "azurerm_resource_group" "rg" {
  name     = "toyotaResourceGroup"
  location = "Japan East"
}
```

#### Step 2: Create the Cosmos DB Account

```hcl
# cosmosdb_account.tf
resource "azurerm_cosmosdb_account" "cosmosdb" {
  name                = "toyotacosmosdb"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  offer_type          = "Standard"
  kind                = "GlobalDocumentDB"

  consistency_policy {
    consistency_level       = "Eventual"
    max_interval_in_seconds = 5
    max_staleness_prefix    = 100
  }

  geo_location {
    location          = "Japan East"
    failover_priority = 0
  }

  geo_location {
    location          = "Japan West"
    failover_priority = 1
  }
}
```

#### Step 3: Create the Database and Container

```hcl
# cosmosdb_database.tf
resource "azurerm_cosmosdb_sql_database" "database" {
  name                = "toyotadb"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
}

# cosmosdb_container.tf
resource "azurerm_cosmosdb_sql_container" "container" {
  name                = "telemetryContainer"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
  database_name       = azurerm_cosmosdb_sql_database.database.name
  partition_key_path  = "/vehicleId"
  throughput          = 3000

  indexing_policy {
    indexing_mode = "consistent"
    included_path {
      path = "/*"
    }
    excluded_path {
      path = "/\"_etag\"/?"
    }
  }
}
```

### 4. HSBC: Financial Services

#### Step 1: Define the Provider and Resource Group

```hcl
# provider.tf
provider "azurerm" {
  features {}
}

# resource_group.tf
resource "azurerm_resource_group" "rg" {
  name     = "hsbcResourceGroup"
  location = "UK South"
}
```

#### Step 2: Create the Cosmos DB Account

```hcl
# cosmosdb_account.tf
resource "azurerm_cosmosdb_account" "cosmosdb" {
  name                = "hsbccosmosdb"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  offer_type          = "Standard"
  kind                = "GlobalDocumentDB"

  consistency_policy {
    consistency_level       = "Strong"
    max_interval_in_seconds = 5
    max_staleness_prefix    = 100
  }

  geo_location {
    location          = "UK South"
    failover_priority = 0
  }

  geo_location {
    location          = "UK West"
    failover_priority = 1
  }
}
```

#### Step 3: Create the Database and Container

```hcl
# cosmosdb_database.tf
resource "azurerm_cosmosdb_sql_database" "database" {
  name                = "hsbcdb"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
}

# cosmosdb_container.tf
resource "azurerm_cosmosdb_sql_container" "container" {
  name                = "transactionContainer"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
  database_name       = azurerm_cosmosdb_sql_database.database.name
  partition_key_path  = "/transactionId"
  throughput          = 5000

  indexing_policy {
    indexing_mode = "consistent"
    included_path {
      path = "/*"
    }
    excluded_path {
      path = "/\"_etag\"/?"
    }
  }
}
```

### 5. Philips Healthcare: Healthcare

#### Step 1: Define the Provider and Resource Group

```hcl
# provider.tf
provider "azurerm" {
  features {}
}

# resource_group.tf
resource "azurerm_resource_group" "rg" {
  name     = "philipsResourceGroup"
  location = "West Europe"
}
```

#### Step 2: Create the Cosmos DB Account

```hcl
# cosmosdb_account.tf
resource "azurerm_cosmosdb_account" "cosmosdb" {
  name                = "philipshealthcosmosdb"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  offer_type          = "Standard"
  kind                = "

GlobalDocumentDB"

  consistency_policy {
    consistency_level       = "Strong"
    max_interval_in_seconds = 5
    max_staleness_prefix    = 100
  }

  geo_location {
    location          = "West Europe"
    failover_priority = 0
  }

  geo_location {
    location          = "North Europe"
    failover_priority = 1
  }
}
```

#### Step 3: Create the Database and Container

```hcl
# cosmosdb_database.tf
resource "azurerm_cosmosdb_sql_database" "database" {
  name                = "philipsdb"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
}

# cosmosdb_container.tf
resource "azurerm_cosmosdb_sql_container" "container" {
  name                = "patientDataContainer"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
  database_name       = azurerm_cosmosdb_sql_database.database.name
  partition_key_path  = "/patientId"
  throughput          = 1000

  indexing_policy {
    indexing_mode = "consistent"
    included_path {
      path = "/*"
    }
    excluded_path {
      path = "/\"_etag\"/?"
    }
  }
}
```

### Applying the Configuration

1. Initialize the Terraform configuration:
   ```sh
   terraform init
   ```

2. Apply the configuration:
   ```sh
   terraform apply
   ```

You will be prompted to confirm the execution of the script. Type `yes` to proceed. Terraform will create the specified resources in Azure for each real-world example scenario. If you need any further customization or additional resources, you can extend these scripts accordingly.


Certainly! Here's a detailed step-by-step explanation of the Terraform scripts for each of the real-world examples:

### 1. Walmart: Retail and E-Commerce

#### Step 1: Define the Provider and Resource Group

**provider.tf**
```hcl
provider "azurerm" {
  features {}
}
```
- **Explanation**: This script defines the Azure provider, which is required to interact with Azure resources. The `features {}` block is a required placeholder for the Azure provider.

**resource_group.tf**
```hcl
resource "azurerm_resource_group" "rg" {
  name     = "walmartResourceGroup"
  location = "East US"
}
```
- **Explanation**: This script creates a resource group named "walmartResourceGroup" in the "East US" location. Resource groups are logical containers for resources deployed in Azure.

#### Step 2: Create the Cosmos DB Account

**cosmosdb_account.tf**
```hcl
resource "azurerm_cosmosdb_account" "cosmosdb" {
  name                = "walmartcosmosdb"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  offer_type          = "Standard"
  kind                = "GlobalDocumentDB"

  consistency_policy {
    consistency_level       = "Strong"
    max_interval_in_seconds = 5
    max_staleness_prefix    = 100
  }

  geo_location {
    location          = "East US"
    failover_priority = 0
  }

  geo_location {
    location          = "West US"
    failover_priority = 1
  }
}
```
- **Explanation**: This script creates a Cosmos DB account named "walmartcosmosdb" in the "walmartResourceGroup" resource group. The account is set to replicate data between the "East US" and "West US" regions, with a strong consistency level for data accuracy. The `geo_location` blocks specify the regions for data replication and their failover priorities.

#### Step 3: Create the Database and Container

**cosmosdb_database.tf**
```hcl
resource "azurerm_cosmosdb_sql_database" "database" {
  name                = "walmartdb"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
}
```
- **Explanation**: This script creates a Cosmos DB SQL database named "walmartdb" within the previously created Cosmos DB account.

**cosmosdb_container.tf**
```hcl
resource "azurerm_cosmosdb_sql_container" "container" {
  name                = "inventoryContainer"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
  database_name       = azurerm_cosmosdb_sql_database.database.name
  partition_key_path  = "/productId"
  throughput          = 1000

  indexing_policy {
    indexing_mode = "consistent"
    included_path {
      path = "/*"
    }
    excluded_path {
      path = "/\"_etag\"/?"
    }
  }
}
```
- **Explanation**: This script creates a container named "inventoryContainer" within the "walmartdb" database. The container uses "/productId" as the partition key, which helps in distributing the data evenly across multiple partitions. The `throughput` is set to 1000 RUs (Request Units), and an indexing policy is defined for efficient querying.

### 2. Microsoft Xbox: Gaming

#### Step 1: Define the Provider and Resource Group

**provider.tf**
```hcl
provider "azurerm" {
  features {}
}
```
- **Explanation**: This is the same as the previous example, defining the Azure provider.

**resource_group.tf**
```hcl
resource "azurerm_resource_group" "rg" {
  name     = "xboxResourceGroup"
  location = "West US"
}
```
- **Explanation**: Creates a resource group named "xboxResourceGroup" in the "West US" location.

#### Step 2: Create the Cosmos DB Account

**cosmosdb_account.tf**
```hcl
resource "azurerm_cosmosdb_account" "cosmosdb" {
  name                = "xboxcosmosdb"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  offer_type          = "Standard"
  kind                = "GlobalDocumentDB"

  consistency_policy {
    consistency_level       = "Session"
    max_interval_in_seconds = 5
    max_staleness_prefix    = 100
  }

  geo_location {
    location          = "West US"
    failover_priority = 0
  }

  geo_location {
    location          = "East US"
    failover_priority = 1
  }
}
```
- **Explanation**: Creates a Cosmos DB account named "xboxcosmosdb" with session consistency, replicating data between "West US" and "East US".

#### Step 3: Create the Database and Container

**cosmosdb_database.tf**
```hcl
resource "azurerm_cosmosdb_sql_database" "database" {
  name                = "xboxdb"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
}
```
- **Explanation**: Creates a database named "xboxdb".

**cosmosdb_container.tf**
```hcl
resource "azurerm_cosmosdb_sql_container" "container" {
  name                = "playerDataContainer"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
  database_name       = azurerm_cosmosdb_sql_database.database.name
  partition_key_path  = "/playerId"
  throughput          = 2000

  indexing_policy {
    indexing_mode = "consistent"
    included_path {
      path = "/*"
    }
    excluded_path {
      path = "/\"_etag\"/?"
    }
  }
}
```
- **Explanation**: Creates a container named "playerDataContainer" with "/playerId" as the partition key, suitable for storing player data with a throughput of 2000 RUs.

### 3. Toyota: IoT and Telemetry

#### Step 1: Define the Provider and Resource Group

**provider.tf**
```hcl
provider "azurerm" {
  features {}
}
```
- **Explanation**: Same as previous examples, defining the Azure provider.

**resource_group.tf**
```hcl
resource "azurerm_resource_group" "rg" {
  name     = "toyotaResourceGroup"
  location = "Japan East"
}
```
- **Explanation**: Creates a resource group named "toyotaResourceGroup" in "Japan East".

#### Step 2: Create the Cosmos DB Account

**cosmosdb_account.tf**
```hcl
resource "azurerm_cosmosdb_account" "cosmosdb" {
  name                = "toyotacosmosdb"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  offer_type          = "Standard"
  kind                = "GlobalDocumentDB"

  consistency_policy {
    consistency_level       = "Eventual"
    max_interval_in_seconds = 5
    max_staleness_prefix    = 100
  }

  geo_location {
    location          = "Japan East"
    failover_priority = 0
  }

  geo_location {
    location          = "Japan West"
    failover_priority = 1
  }
}
```
- **Explanation**: Creates a Cosmos DB account named "toyotacosmosdb" with eventual consistency, replicating data between "Japan East" and "Japan West".

#### Step 3: Create the Database and Container

**cosmosdb_database.tf**
```hcl
resource "azurerm_cosmosdb_sql_database" "database" {
  name                = "toyotadb"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
}
```
- **Explanation**: Creates a database named "toyotadb".

**cosmosdb_container.tf**
```hcl
resource "azurerm_cosmosdb_sql_container" "container" {
  name                = "telemetryContainer"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
  database_name       = azurerm_cosmosdb_sql_database.database.name
  partition_key_path  = "/vehicleId"
  throughput          = 3000

  indexing_policy {
    indexing_mode = "consistent"
    included_path {
      path = "/*"
    }
    excluded_path {
      path = "/\"_etag\"/?"
    }
  }
}
```
- **Explanation**: Creates a container named "telemetryContainer" with "/vehicleId" as the partition key, suitable for storing telemetry data with a throughput of 3000 RUs.

### 4. HSBC: Financial Services

#### Step 1: Define the Provider and Resource Group

**provider.tf**
```hcl
provider "azurerm" {
  features {}
}
```
- **Explanation**: Same as previous examples, defining the Azure provider.

**resource_group.tf**
```hcl
resource "azurerm

_resource_group" "rg" {
  name     = "hsbcResourceGroup"
  location = "UK South"
}
```
- **Explanation**: Creates a resource group named "hsbcResourceGroup" in "UK South".

#### Step 2: Create the Cosmos DB Account

**cosmosdb_account.tf**
```hcl
resource "azurerm_cosmosdb_account" "cosmosdb" {
  name                = "hsbccosmosdb"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  offer_type          = "Standard"
  kind                = "GlobalDocumentDB"

  consistency_policy {
    consistency_level       = "Strong"
    max_interval_in_seconds = 5
    max_staleness_prefix    = 100
  }

  geo_location {
    location          = "UK South"
    failover_priority = 0
  }

  geo_location {
    location          = "UK West"
    failover_priority = 1
  }
}
```
- **Explanation**: Creates a Cosmos DB account named "hsbccosmosdb" with strong consistency, replicating data between "UK South" and "UK West".

#### Step 3: Create the Database and Container

**cosmosdb_database.tf**
```hcl
resource "azurerm_cosmosdb_sql_database" "database" {
  name                = "hsbcdb"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
}
```
- **Explanation**: Creates a database named "hsbcdb".

**cosmosdb_container.tf**
```hcl
resource "azurerm_cosmosdb_sql_container" "container" {
  name                = "transactionContainer"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
  database_name       = azurerm_cosmosdb_sql_database.database.name
  partition_key_path  = "/transactionId"
  throughput          = 5000

  indexing_policy {
    indexing_mode = "consistent"
    included_path {
      path = "/*"
    }
    excluded_path {
      path = "/\"_etag\"/?"
    }
  }
}
```
- **Explanation**: Creates a container named "transactionContainer" with "/transactionId" as the partition key, suitable for storing transaction data with a throughput of 5000 RUs.

### 5. Philips Healthcare: Healthcare

#### Step 1: Define the Provider and Resource Group

**provider.tf**
```hcl
provider "azurerm" {
  features {}
}
```
- **Explanation**: Same as previous examples, defining the Azure provider.

**resource_group.tf**
```hcl
resource "azurerm_resource_group" "rg" {
  name     = "philipsResourceGroup"
  location = "West Europe"
}
```
- **Explanation**: Creates a resource group named "philipsResourceGroup" in "West Europe".

#### Step 2: Create the Cosmos DB Account

**cosmosdb_account.tf**
```hcl
resource "azurerm_cosmosdb_account" "cosmosdb" {
  name                = "philipshealthcosmosdb"
  location            = azurerm_resource_group.rg.location
  resource_group_name = azurerm_resource_group.rg.name
  offer_type          = "Standard"
  kind                = "GlobalDocumentDB"

  consistency_policy {
    consistency_level       = "Strong"
    max_interval_in_seconds = 5
    max_staleness_prefix    = 100
  }

  geo_location {
    location          = "West Europe"
    failover_priority = 0
  }

  geo_location {
    location          = "North Europe"
    failover_priority = 1
  }
}
```
- **Explanation**: Creates a Cosmos DB account named "philipshealthcosmosdb" with strong consistency, replicating data between "West Europe" and "North Europe".

#### Step 3: Create the Database and Container

**cosmosdb_database.tf**
```hcl
resource "azurerm_cosmosdb_sql_database" "database" {
  name                = "philipsdb"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
}
```
- **Explanation**: Creates a database named "philipsdb".

**cosmosdb_container.tf**
```hcl
resource "azurerm_cosmosdb_sql_container" "container" {
  name                = "patientDataContainer"
  resource_group_name = azurerm_resource_group.rg.name
  account_name        = azurerm_cosmosdb_account.cosmosdb.name
  database_name       = azurerm_cosmosdb_sql_database.database.name
  partition_key_path  = "/patientId"
  throughput          = 1000

  indexing_policy {
    indexing_mode = "consistent"
    included_path {
      path = "/*"
    }
    excluded_path {
      path = "/\"_etag\"/?"
    }
  }
}
```
- **Explanation**: Creates a container named "patientDataContainer" with "/patientId" as the partition key, suitable for storing patient data with a throughput of 1000 RUs.

### Applying the Configuration

1. **Initialize the Terraform configuration**:
   ```sh
   terraform init
   ```
   - **Explanation**: This command initializes the working directory containing the Terraform configuration files. It will download the necessary provider plugins.

2. **Apply the configuration**:
   ```sh
   terraform apply
   ```
   - **Explanation**: This command will show a preview of the changes that will be made. You will be prompted to confirm the execution. Type `yes` to proceed. Terraform will then create the specified resources in Azure.

By following these steps and using the provided scripts, you can set up Azure Cosmos DB instances for different real-world scenarios in a consistent and automated manner using Terraform. Adjustments can be made to the scripts based on specific needs or additional configurations required for your use cases.

